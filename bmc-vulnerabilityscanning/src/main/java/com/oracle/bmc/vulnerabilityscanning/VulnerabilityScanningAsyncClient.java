/**
 * Copyright (c) 2016, 2023, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
package com.oracle.bmc.vulnerabilityscanning;

import com.oracle.bmc.vulnerabilityscanning.internal.http.*;
import com.oracle.bmc.vulnerabilityscanning.requests.*;
import com.oracle.bmc.vulnerabilityscanning.responses.*;

/**
 * Async client implementation for VulnerabilityScanning service. <br/>
 * There are two ways to use async client:
 * 1. Use AsyncHandler: using AsyncHandler, if the response to the call is an {@link java.io.InputStream}, like
 * getObject Api in object storage service, developers need to process the stream in AsyncHandler, and not anywhere else,
 * because the stream will be closed right after the AsyncHandler is invoked. <br/>
 * 2. Use Java Future: using Java Future, developers need to close the stream after they are done with the Java Future.<br/>
 * Accessing the result should be done in a mutually exclusive manner, either through the Future or the AsyncHandler,
 * but not both.  If the Future is used, the caller should pass in null as the AsyncHandler.  If the AsyncHandler
 * is used, it is still safe to use the Future to determine whether or not the request was completed via
 * Future.isDone/isCancelled.<br/>
 * Please refer to https://github.com/oracle/oci-java-sdk/blob/master/bmc-examples/src/main/java/ResteasyClientWithObjectStorageExample.java
 */
@javax.annotation.Generated(value = "OracleSDKGenerator", comments = "API Version: 20210215")
public class VulnerabilityScanningAsyncClient implements VulnerabilityScanningAsync {
    /**
     * Service instance for VulnerabilityScanning.
     */
    public static final com.oracle.bmc.Service SERVICE =
            com.oracle.bmc.Services.serviceBuilder()
                    .serviceName("VULNERABILITYSCANNING")
                    .serviceEndpointPrefix("")
                    .serviceEndpointTemplate("https://vss-cp-api.{region}.oci.{secondLevelDomain}")
                    .build();

    private static final org.slf4j.Logger LOG =
            org.slf4j.LoggerFactory.getLogger(VulnerabilityScanningAsyncClient.class);

    private final com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider
            authenticationDetailsProvider;

    private final org.glassfish.jersey.apache.connector.ApacheConnectionClosingStrategy
            apacheConnectionClosingStrategy;
    private final com.oracle.bmc.http.internal.RestClientFactory restClientFactory;
    private final com.oracle.bmc.http.signing.RequestSignerFactory defaultRequestSignerFactory;
    private final java.util.Map<
                    com.oracle.bmc.http.signing.SigningStrategy,
                    com.oracle.bmc.http.signing.RequestSignerFactory>
            signingStrategyRequestSignerFactories;
    private final boolean isNonBufferingApacheClient;
    private final com.oracle.bmc.ClientConfiguration clientConfigurationToUse;

    /**
     * Used to synchronize any updates on the `this.client` object.
     */
    private final Object clientUpdate = new Object();

    /**
     * Stores the actual client object used to make the API calls.
     * Note: This object can get refreshed periodically, hence it's important to keep any updates synchronized.
     *       For any writes to the object, please synchronize on `this.clientUpdate`.
     */
    private volatile com.oracle.bmc.http.internal.RestClient client;

    /**
     * Keeps track of the last endpoint that was assigned to the client, which in turn can be used when the client is refreshed.
     * Note: Always synchronize on `this.clientUpdate` when reading/writing this field.
     */
    private volatile String overrideEndpoint = null;

    /**
     * Creates a new service instance using the given authentication provider.
     * @param authenticationDetailsProvider The authentication details provider, required.
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.BasicAuthenticationDetailsProvider authenticationDetailsProvider) {
        this(authenticationDetailsProvider, null);
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.BasicAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration) {
        this(authenticationDetailsProvider, configuration, null);
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.  Additionally,
     * a Consumer can be provided that will be invoked whenever a REST Client is created to allow for additional configuration/customization.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     * @param clientConfigurator ClientConfigurator that will be invoked for additional configuration of a REST client, optional.
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.BasicAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration,
            com.oracle.bmc.http.ClientConfigurator clientConfigurator) {
        this(
                authenticationDetailsProvider,
                configuration,
                clientConfigurator,
                new com.oracle.bmc.http.signing.internal.DefaultRequestSignerFactory(
                        com.oracle.bmc.http.signing.SigningStrategy.STANDARD));
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.  Additionally,
     * a Consumer can be provided that will be invoked whenever a REST Client is created to allow for additional configuration/customization.
     * <p>
     * This is an advanced constructor for clients that want to take control over how requests are signed.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     * @param clientConfigurator ClientConfigurator that will be invoked for additional configuration of a REST client, optional.
     * @param defaultRequestSignerFactory The request signer factory used to create the request signer for this service.
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration,
            com.oracle.bmc.http.ClientConfigurator clientConfigurator,
            com.oracle.bmc.http.signing.RequestSignerFactory defaultRequestSignerFactory) {
        this(
                authenticationDetailsProvider,
                configuration,
                clientConfigurator,
                defaultRequestSignerFactory,
                new java.util.ArrayList<com.oracle.bmc.http.ClientConfigurator>());
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.  Additionally,
     * a Consumer can be provided that will be invoked whenever a REST Client is created to allow for additional configuration/customization.
     * <p>
     * This is an advanced constructor for clients that want to take control over how requests are signed.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     * @param clientConfigurator ClientConfigurator that will be invoked for additional configuration of a REST client, optional.
     * @param defaultRequestSignerFactory The request signer factory used to create the request signer for this service.
     * @param additionalClientConfigurators Additional client configurators to be run after the primary configurator.
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration,
            com.oracle.bmc.http.ClientConfigurator clientConfigurator,
            com.oracle.bmc.http.signing.RequestSignerFactory defaultRequestSignerFactory,
            java.util.List<com.oracle.bmc.http.ClientConfigurator> additionalClientConfigurators) {
        this(
                authenticationDetailsProvider,
                configuration,
                clientConfigurator,
                defaultRequestSignerFactory,
                additionalClientConfigurators,
                null);
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.  Additionally,
     * a Consumer can be provided that will be invoked whenever a REST Client is created to allow for additional configuration/customization.
     * <p>
     * This is an advanced constructor for clients that want to take control over how requests are signed.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     * @param clientConfigurator ClientConfigurator that will be invoked for additional configuration of a REST client, optional.
     * @param defaultRequestSignerFactory The request signer factory used to create the request signer for this service.
     * @param additionalClientConfigurators Additional client configurators to be run after the primary configurator.
     * @param endpoint Endpoint, or null to leave unset (note, may be overridden by {@code authenticationDetailsProvider})
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration,
            com.oracle.bmc.http.ClientConfigurator clientConfigurator,
            com.oracle.bmc.http.signing.RequestSignerFactory defaultRequestSignerFactory,
            java.util.List<com.oracle.bmc.http.ClientConfigurator> additionalClientConfigurators,
            String endpoint) {
        this(
                authenticationDetailsProvider,
                configuration,
                clientConfigurator,
                defaultRequestSignerFactory,
                com.oracle.bmc.http.signing.internal.DefaultRequestSignerFactory
                        .createDefaultRequestSignerFactories(),
                additionalClientConfigurators,
                endpoint);
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.  Additionally,
     * a Consumer can be provided that will be invoked whenever a REST Client is created to allow for additional configuration/customization.
     * <p>
     * This is an advanced constructor for clients that want to take control over how requests are signed.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     * @param clientConfigurator ClientConfigurator that will be invoked for additional configuration of a REST client, optional.
     * @param defaultRequestSignerFactory The request signer factory used to create the request signer for this service.
     * @param signingStrategyRequestSignerFactories The request signer factories for each signing strategy used to create the request signer
     * @param additionalClientConfigurators Additional client configurators to be run after the primary configurator.
     * @param endpoint Endpoint, or null to leave unset (note, may be overridden by {@code authenticationDetailsProvider})
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration,
            com.oracle.bmc.http.ClientConfigurator clientConfigurator,
            com.oracle.bmc.http.signing.RequestSignerFactory defaultRequestSignerFactory,
            java.util.Map<
                            com.oracle.bmc.http.signing.SigningStrategy,
                            com.oracle.bmc.http.signing.RequestSignerFactory>
                    signingStrategyRequestSignerFactories,
            java.util.List<com.oracle.bmc.http.ClientConfigurator> additionalClientConfigurators,
            String endpoint) {
        this(
                authenticationDetailsProvider,
                configuration,
                clientConfigurator,
                defaultRequestSignerFactory,
                signingStrategyRequestSignerFactories,
                additionalClientConfigurators,
                endpoint,
                com.oracle.bmc.http.internal.RestClientFactoryBuilder.builder());
    }

    /**
     * Creates a new service instance using the given authentication provider and client configuration.  Additionally,
     * a Consumer can be provided that will be invoked whenever a REST Client is created to allow for additional configuration/customization.
     * <p>
     * This is an advanced constructor for clients that want to take control over how requests are signed.
     * @param authenticationDetailsProvider The authentication details provider, required.
     * @param configuration The client configuration, optional.
     * @param clientConfigurator ClientConfigurator that will be invoked for additional configuration of a REST client, optional.
     * @param defaultRequestSignerFactory The request signer factory used to create the request signer for this service.
     * @param signingStrategyRequestSignerFactories The request signer factories for each signing strategy used to create the request signer
     * @param additionalClientConfigurators Additional client configurators to be run after the primary configurator.
     * @param endpoint Endpoint, or null to leave unset (note, may be overridden by {@code authenticationDetailsProvider})
     * @param restClientFactoryBuilder the builder for the {@link com.oracle.bmc.http.internal.RestClientFactory}
     */
    public VulnerabilityScanningAsyncClient(
            com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider authenticationDetailsProvider,
            com.oracle.bmc.ClientConfiguration configuration,
            com.oracle.bmc.http.ClientConfigurator clientConfigurator,
            com.oracle.bmc.http.signing.RequestSignerFactory defaultRequestSignerFactory,
            java.util.Map<
                            com.oracle.bmc.http.signing.SigningStrategy,
                            com.oracle.bmc.http.signing.RequestSignerFactory>
                    signingStrategyRequestSignerFactories,
            java.util.List<com.oracle.bmc.http.ClientConfigurator> additionalClientConfigurators,
            String endpoint,
            com.oracle.bmc.http.internal.RestClientFactoryBuilder restClientFactoryBuilder) {
        this.authenticationDetailsProvider = authenticationDetailsProvider;
        java.util.List<com.oracle.bmc.http.ClientConfigurator> authenticationDetailsConfigurators =
                new java.util.ArrayList<>();
        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.ProvidesClientConfigurators) {
            authenticationDetailsConfigurators.addAll(
                    ((com.oracle.bmc.auth.ProvidesClientConfigurators)
                                    this.authenticationDetailsProvider)
                            .getClientConfigurators());
        }
        java.util.List<com.oracle.bmc.http.ClientConfigurator> allConfigurators =
                new java.util.ArrayList<>(additionalClientConfigurators);
        allConfigurators.addAll(authenticationDetailsConfigurators);
        this.restClientFactory =
                restClientFactoryBuilder
                        .clientConfigurator(clientConfigurator)
                        .additionalClientConfigurators(allConfigurators)
                        .build();
        this.isNonBufferingApacheClient =
                com.oracle.bmc.http.ApacheUtils.isNonBufferingClientConfigurator(
                        restClientFactory.getClientConfigurator());
        this.apacheConnectionClosingStrategy =
                com.oracle.bmc.http.ApacheUtils.getApacheConnectionClosingStrategy(
                        restClientFactory.getClientConfigurator());
        this.defaultRequestSignerFactory = defaultRequestSignerFactory;
        this.signingStrategyRequestSignerFactories = signingStrategyRequestSignerFactories;
        this.clientConfigurationToUse = configuration;

        this.refreshClient();

        if (this.authenticationDetailsProvider instanceof com.oracle.bmc.auth.RegionProvider) {
            com.oracle.bmc.auth.RegionProvider provider =
                    (com.oracle.bmc.auth.RegionProvider) this.authenticationDetailsProvider;

            if (provider.getRegion() != null) {
                this.setRegion(provider.getRegion());
                if (endpoint != null) {
                    LOG.info(
                            "Authentication details provider configured for region '{}', but endpoint specifically set to '{}'. Using endpoint setting instead of region.",
                            provider.getRegion(),
                            endpoint);
                }
            }
        }
        if (endpoint != null) {
            setEndpoint(endpoint);
        }
    }

    /**
     * Create a builder for this client.
     * @return builder
     */
    public static Builder builder() {
        return new Builder(SERVICE);
    }

    /**
     * Builder class for this client. The "authenticationDetailsProvider" is required and must be passed to the
     * {@link #build(AbstractAuthenticationDetailsProvider)} method.
     */
    public static class Builder
            extends com.oracle.bmc.common.RegionalClientBuilder<
                    Builder, VulnerabilityScanningAsyncClient> {
        private Builder(com.oracle.bmc.Service service) {
            super(service);
            requestSignerFactory =
                    new com.oracle.bmc.http.signing.internal.DefaultRequestSignerFactory(
                            com.oracle.bmc.http.signing.SigningStrategy.STANDARD);
        }

        /**
         * Build the client.
         * @param authenticationDetailsProvider authentication details provider
         * @return the client
         */
        public VulnerabilityScanningAsyncClient build(
                @javax.annotation.Nonnull
                com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider
                        authenticationDetailsProvider) {
            if (authenticationDetailsProvider == null) {
                throw new NullPointerException(
                        "authenticationDetailsProvider is marked non-null but is null");
            }
            return new VulnerabilityScanningAsyncClient(
                    authenticationDetailsProvider,
                    configuration,
                    clientConfigurator,
                    requestSignerFactory,
                    signingStrategyRequestSignerFactories,
                    additionalClientConfigurators,
                    endpoint);
        }
    }

    com.oracle.bmc.http.internal.RestClient getClient() {
        return client;
    }

    @Override
    public void refreshClient() {
        LOG.info("Refreshing client '{}'.", this.client != null ? this.client.getClass() : null);
        com.oracle.bmc.http.signing.RequestSigner defaultRequestSigner =
                this.defaultRequestSignerFactory.createRequestSigner(
                        SERVICE, this.authenticationDetailsProvider);

        java.util.Map<
                        com.oracle.bmc.http.signing.SigningStrategy,
                        com.oracle.bmc.http.signing.RequestSigner>
                requestSigners = new java.util.HashMap<>();
        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.BasicAuthenticationDetailsProvider) {
            for (com.oracle.bmc.http.signing.SigningStrategy s :
                    com.oracle.bmc.http.signing.SigningStrategy.values()) {
                requestSigners.put(
                        s,
                        this.signingStrategyRequestSignerFactories
                                .get(s)
                                .createRequestSigner(SERVICE, authenticationDetailsProvider));
            }
        }

        com.oracle.bmc.http.internal.RestClient refreshedClient =
                this.restClientFactory.create(
                        defaultRequestSigner,
                        requestSigners,
                        this.clientConfigurationToUse,
                        this.isNonBufferingApacheClient);

        synchronized (clientUpdate) {
            if (this.overrideEndpoint != null) {
                refreshedClient.setEndpoint(this.overrideEndpoint);
            }

            this.client = refreshedClient;
        }

        LOG.info("Refreshed client '{}'.", this.client != null ? this.client.getClass() : null);
    }

    @Override
    public void setEndpoint(String endpoint) {
        LOG.info("Setting endpoint to {}", endpoint);

        synchronized (clientUpdate) {
            this.overrideEndpoint = endpoint;
            client.setEndpoint(endpoint);
        }
    }

    @Override
    public String getEndpoint() {
        String endpoint = null;
        java.net.URI uri = client.getBaseTarget().getUri();
        if (uri != null) {
            endpoint = uri.toString();
        }
        return endpoint;
    }

    @Override
    public void setRegion(com.oracle.bmc.Region region) {
        java.util.Optional<String> endpoint =
                com.oracle.bmc.internal.GuavaUtils.adaptFromGuava(region.getEndpoint(SERVICE));
        if (endpoint.isPresent()) {
            setEndpoint(endpoint.get());
        } else {
            throw new IllegalArgumentException(
                    "Endpoint for " + SERVICE + " is not known in region " + region);
        }
    }

    @Override
    public void setRegion(String regionId) {
        regionId = regionId.toLowerCase(java.util.Locale.ENGLISH);
        try {
            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);
            setRegion(region);
        } catch (IllegalArgumentException e) {
            LOG.info("Unknown regionId '{}', falling back to default endpoint format", regionId);
            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(SERVICE, regionId);
            setEndpoint(endpoint);
        }
    }

    @Override
    public void close() {
        client.close();
    }

    @Override
    public java.util.concurrent.Future<ChangeContainerScanRecipeCompartmentResponse>
            changeContainerScanRecipeCompartment(
                    ChangeContainerScanRecipeCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeContainerScanRecipeCompartmentRequest,
                                    ChangeContainerScanRecipeCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeContainerScanRecipeCompartment");
        final ChangeContainerScanRecipeCompartmentRequest interceptedRequest =
                ChangeContainerScanRecipeCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeContainerScanRecipeCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeContainerScanRecipeCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanRecipe/ChangeContainerScanRecipeCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeContainerScanRecipeCompartmentResponse>
                transformer =
                        ChangeContainerScanRecipeCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeContainerScanRecipeCompartmentRequest,
                        ChangeContainerScanRecipeCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeContainerScanRecipeCompartmentRequest,
                                ChangeContainerScanRecipeCompartmentResponse>,
                        java.util.concurrent.Future<ChangeContainerScanRecipeCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeContainerScanRecipeCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeContainerScanRecipeCompartmentRequest,
                    ChangeContainerScanRecipeCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeContainerScanResultCompartmentResponse>
            changeContainerScanResultCompartment(
                    ChangeContainerScanResultCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeContainerScanResultCompartmentRequest,
                                    ChangeContainerScanResultCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeContainerScanResultCompartment");
        final ChangeContainerScanResultCompartmentRequest interceptedRequest =
                ChangeContainerScanResultCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeContainerScanResultCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeContainerScanResultCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanResult/ChangeContainerScanResultCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeContainerScanResultCompartmentResponse>
                transformer =
                        ChangeContainerScanResultCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeContainerScanResultCompartmentRequest,
                        ChangeContainerScanResultCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeContainerScanResultCompartmentRequest,
                                ChangeContainerScanResultCompartmentResponse>,
                        java.util.concurrent.Future<ChangeContainerScanResultCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeContainerScanResultCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeContainerScanResultCompartmentRequest,
                    ChangeContainerScanResultCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeContainerScanTargetCompartmentResponse>
            changeContainerScanTargetCompartment(
                    ChangeContainerScanTargetCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeContainerScanTargetCompartmentRequest,
                                    ChangeContainerScanTargetCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeContainerScanTargetCompartment");
        final ChangeContainerScanTargetCompartmentRequest interceptedRequest =
                ChangeContainerScanTargetCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeContainerScanTargetCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeContainerScanTargetCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanTarget/ChangeContainerScanTargetCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeContainerScanTargetCompartmentResponse>
                transformer =
                        ChangeContainerScanTargetCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeContainerScanTargetCompartmentRequest,
                        ChangeContainerScanTargetCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeContainerScanTargetCompartmentRequest,
                                ChangeContainerScanTargetCompartmentResponse>,
                        java.util.concurrent.Future<ChangeContainerScanTargetCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeContainerScanTargetCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeContainerScanTargetCompartmentRequest,
                    ChangeContainerScanTargetCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeHostAgentScanResultCompartmentResponse>
            changeHostAgentScanResultCompartment(
                    ChangeHostAgentScanResultCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeHostAgentScanResultCompartmentRequest,
                                    ChangeHostAgentScanResultCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeHostAgentScanResultCompartment");
        final ChangeHostAgentScanResultCompartmentRequest interceptedRequest =
                ChangeHostAgentScanResultCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeHostAgentScanResultCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeHostAgentScanResultCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostAgentScanResult/ChangeHostAgentScanResultCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeHostAgentScanResultCompartmentResponse>
                transformer =
                        ChangeHostAgentScanResultCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeHostAgentScanResultCompartmentRequest,
                        ChangeHostAgentScanResultCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeHostAgentScanResultCompartmentRequest,
                                ChangeHostAgentScanResultCompartmentResponse>,
                        java.util.concurrent.Future<ChangeHostAgentScanResultCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeHostAgentScanResultCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeHostAgentScanResultCompartmentRequest,
                    ChangeHostAgentScanResultCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeHostCisBenchmarkScanResultCompartmentResponse>
            changeHostCisBenchmarkScanResultCompartment(
                    ChangeHostCisBenchmarkScanResultCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeHostCisBenchmarkScanResultCompartmentRequest,
                                    ChangeHostCisBenchmarkScanResultCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeHostCisBenchmarkScanResultCompartment");
        final ChangeHostCisBenchmarkScanResultCompartmentRequest interceptedRequest =
                ChangeHostCisBenchmarkScanResultCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeHostCisBenchmarkScanResultCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeHostCisBenchmarkScanResultCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostCisBenchmarkScanResult/ChangeHostCisBenchmarkScanResultCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response,
                        ChangeHostCisBenchmarkScanResultCompartmentResponse>
                transformer =
                        ChangeHostCisBenchmarkScanResultCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeHostCisBenchmarkScanResultCompartmentRequest,
                        ChangeHostCisBenchmarkScanResultCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeHostCisBenchmarkScanResultCompartmentRequest,
                                ChangeHostCisBenchmarkScanResultCompartmentResponse>,
                        java.util.concurrent.Future<
                                ChangeHostCisBenchmarkScanResultCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest
                                        .getChangeHostCisBenchmarkScanResultCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeHostCisBenchmarkScanResultCompartmentRequest,
                    ChangeHostCisBenchmarkScanResultCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeHostEndpointProtectionScanResultCompartmentResponse>
            changeHostEndpointProtectionScanResultCompartment(
                    ChangeHostEndpointProtectionScanResultCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeHostEndpointProtectionScanResultCompartmentRequest,
                                    ChangeHostEndpointProtectionScanResultCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeHostEndpointProtectionScanResultCompartment");
        final ChangeHostEndpointProtectionScanResultCompartmentRequest interceptedRequest =
                ChangeHostEndpointProtectionScanResultCompartmentConverter.interceptRequest(
                        request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeHostEndpointProtectionScanResultCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeHostEndpointProtectionScanResultCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostEndpointProtectionScanResult/ChangeHostEndpointProtectionScanResultCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response,
                        ChangeHostEndpointProtectionScanResultCompartmentResponse>
                transformer =
                        ChangeHostEndpointProtectionScanResultCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeHostEndpointProtectionScanResultCompartmentRequest,
                        ChangeHostEndpointProtectionScanResultCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeHostEndpointProtectionScanResultCompartmentRequest,
                                ChangeHostEndpointProtectionScanResultCompartmentResponse>,
                        java.util.concurrent.Future<
                                ChangeHostEndpointProtectionScanResultCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest
                                        .getChangeHostEndpointProtectionScanResultCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeHostEndpointProtectionScanResultCompartmentRequest,
                    ChangeHostEndpointProtectionScanResultCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeHostPortScanResultCompartmentResponse>
            changeHostPortScanResultCompartment(
                    ChangeHostPortScanResultCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeHostPortScanResultCompartmentRequest,
                                    ChangeHostPortScanResultCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeHostPortScanResultCompartment");
        final ChangeHostPortScanResultCompartmentRequest interceptedRequest =
                ChangeHostPortScanResultCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeHostPortScanResultCompartmentConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeHostPortScanResultCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostPortScanResult/ChangeHostPortScanResultCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeHostPortScanResultCompartmentResponse>
                transformer =
                        ChangeHostPortScanResultCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeHostPortScanResultCompartmentRequest,
                        ChangeHostPortScanResultCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeHostPortScanResultCompartmentRequest,
                                ChangeHostPortScanResultCompartmentResponse>,
                        java.util.concurrent.Future<ChangeHostPortScanResultCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeHostPortScanResultCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeHostPortScanResultCompartmentRequest,
                    ChangeHostPortScanResultCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeHostScanRecipeCompartmentResponse>
            changeHostScanRecipeCompartment(
                    ChangeHostScanRecipeCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeHostScanRecipeCompartmentRequest,
                                    ChangeHostScanRecipeCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeHostScanRecipeCompartment");
        final ChangeHostScanRecipeCompartmentRequest interceptedRequest =
                ChangeHostScanRecipeCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeHostScanRecipeCompartmentConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeHostScanRecipeCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanRecipe/ChangeHostScanRecipeCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeHostScanRecipeCompartmentResponse>
                transformer =
                        ChangeHostScanRecipeCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeHostScanRecipeCompartmentRequest,
                        ChangeHostScanRecipeCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeHostScanRecipeCompartmentRequest,
                                ChangeHostScanRecipeCompartmentResponse>,
                        java.util.concurrent.Future<ChangeHostScanRecipeCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeHostScanRecipeCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeHostScanRecipeCompartmentRequest,
                    ChangeHostScanRecipeCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ChangeHostScanTargetCompartmentResponse>
            changeHostScanTargetCompartment(
                    ChangeHostScanTargetCompartmentRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ChangeHostScanTargetCompartmentRequest,
                                    ChangeHostScanTargetCompartmentResponse>
                            handler) {
        LOG.trace("Called async changeHostScanTargetCompartment");
        final ChangeHostScanTargetCompartmentRequest interceptedRequest =
                ChangeHostScanTargetCompartmentConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ChangeHostScanTargetCompartmentConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ChangeHostScanTargetCompartment",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTarget/ChangeHostScanTargetCompartment");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ChangeHostScanTargetCompartmentResponse>
                transformer =
                        ChangeHostScanTargetCompartmentConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ChangeHostScanTargetCompartmentRequest,
                        ChangeHostScanTargetCompartmentResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ChangeHostScanTargetCompartmentRequest,
                                ChangeHostScanTargetCompartmentResponse>,
                        java.util.concurrent.Future<ChangeHostScanTargetCompartmentResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getChangeHostScanTargetCompartmentDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ChangeHostScanTargetCompartmentRequest,
                    ChangeHostScanTargetCompartmentResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<CreateContainerScanRecipeResponse> createContainerScanRecipe(
            CreateContainerScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            CreateContainerScanRecipeRequest, CreateContainerScanRecipeResponse>
                    handler) {
        LOG.trace("Called async createContainerScanRecipe");
        final CreateContainerScanRecipeRequest interceptedRequest =
                CreateContainerScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                CreateContainerScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "CreateContainerScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanRecipe/CreateContainerScanRecipe");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, CreateContainerScanRecipeResponse>
                transformer =
                        CreateContainerScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        CreateContainerScanRecipeRequest, CreateContainerScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                CreateContainerScanRecipeRequest,
                                CreateContainerScanRecipeResponse>,
                        java.util.concurrent.Future<CreateContainerScanRecipeResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getCreateContainerScanRecipeDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    CreateContainerScanRecipeRequest, CreateContainerScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<CreateContainerScanTargetResponse> createContainerScanTarget(
            CreateContainerScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            CreateContainerScanTargetRequest, CreateContainerScanTargetResponse>
                    handler) {
        LOG.trace("Called async createContainerScanTarget");
        final CreateContainerScanTargetRequest interceptedRequest =
                CreateContainerScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                CreateContainerScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "CreateContainerScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanTarget/CreateContainerScanTarget");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, CreateContainerScanTargetResponse>
                transformer =
                        CreateContainerScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        CreateContainerScanTargetRequest, CreateContainerScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                CreateContainerScanTargetRequest,
                                CreateContainerScanTargetResponse>,
                        java.util.concurrent.Future<CreateContainerScanTargetResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getCreateContainerScanTargetDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    CreateContainerScanTargetRequest, CreateContainerScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<CreateHostScanRecipeResponse> createHostScanRecipe(
            CreateHostScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            CreateHostScanRecipeRequest, CreateHostScanRecipeResponse>
                    handler) {
        LOG.trace("Called async createHostScanRecipe");
        final CreateHostScanRecipeRequest interceptedRequest =
                CreateHostScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                CreateHostScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "CreateHostScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanRecipe/CreateHostScanRecipe");
        final java.util.function.Function<javax.ws.rs.core.Response, CreateHostScanRecipeResponse>
                transformer =
                        CreateHostScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        CreateHostScanRecipeRequest, CreateHostScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                CreateHostScanRecipeRequest, CreateHostScanRecipeResponse>,
                        java.util.concurrent.Future<CreateHostScanRecipeResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getCreateHostScanRecipeDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    CreateHostScanRecipeRequest, CreateHostScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<CreateHostScanTargetResponse> createHostScanTarget(
            CreateHostScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            CreateHostScanTargetRequest, CreateHostScanTargetResponse>
                    handler) {
        LOG.trace("Called async createHostScanTarget");
        final CreateHostScanTargetRequest interceptedRequest =
                CreateHostScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                CreateHostScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.http.internal.RetryTokenUtils.addRetryToken(ib);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "CreateHostScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTarget/CreateHostScanTarget");
        final java.util.function.Function<javax.ws.rs.core.Response, CreateHostScanTargetResponse>
                transformer =
                        CreateHostScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        CreateHostScanTargetRequest, CreateHostScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                CreateHostScanTargetRequest, CreateHostScanTargetResponse>,
                        java.util.concurrent.Future<CreateHostScanTargetResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getCreateHostScanTargetDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    CreateHostScanTargetRequest, CreateHostScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteContainerScanRecipeResponse> deleteContainerScanRecipe(
            DeleteContainerScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteContainerScanRecipeRequest, DeleteContainerScanRecipeResponse>
                    handler) {
        LOG.trace("Called async deleteContainerScanRecipe");
        final DeleteContainerScanRecipeRequest interceptedRequest =
                DeleteContainerScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteContainerScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteContainerScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanRecipe/DeleteContainerScanRecipe");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteContainerScanRecipeResponse>
                transformer =
                        DeleteContainerScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteContainerScanRecipeRequest, DeleteContainerScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteContainerScanRecipeRequest,
                                DeleteContainerScanRecipeResponse>,
                        java.util.concurrent.Future<DeleteContainerScanRecipeResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteContainerScanRecipeRequest, DeleteContainerScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteContainerScanResultResponse> deleteContainerScanResult(
            DeleteContainerScanResultRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteContainerScanResultRequest, DeleteContainerScanResultResponse>
                    handler) {
        LOG.trace("Called async deleteContainerScanResult");
        final DeleteContainerScanResultRequest interceptedRequest =
                DeleteContainerScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteContainerScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteContainerScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanResult/DeleteContainerScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteContainerScanResultResponse>
                transformer =
                        DeleteContainerScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteContainerScanResultRequest, DeleteContainerScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteContainerScanResultRequest,
                                DeleteContainerScanResultResponse>,
                        java.util.concurrent.Future<DeleteContainerScanResultResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteContainerScanResultRequest, DeleteContainerScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteContainerScanTargetResponse> deleteContainerScanTarget(
            DeleteContainerScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteContainerScanTargetRequest, DeleteContainerScanTargetResponse>
                    handler) {
        LOG.trace("Called async deleteContainerScanTarget");
        final DeleteContainerScanTargetRequest interceptedRequest =
                DeleteContainerScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteContainerScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteContainerScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanTarget/DeleteContainerScanTarget");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteContainerScanTargetResponse>
                transformer =
                        DeleteContainerScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteContainerScanTargetRequest, DeleteContainerScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteContainerScanTargetRequest,
                                DeleteContainerScanTargetResponse>,
                        java.util.concurrent.Future<DeleteContainerScanTargetResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteContainerScanTargetRequest, DeleteContainerScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteHostAgentScanResultResponse> deleteHostAgentScanResult(
            DeleteHostAgentScanResultRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteHostAgentScanResultRequest, DeleteHostAgentScanResultResponse>
                    handler) {
        LOG.trace("Called async deleteHostAgentScanResult");
        final DeleteHostAgentScanResultRequest interceptedRequest =
                DeleteHostAgentScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteHostAgentScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteHostAgentScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostAgentScanResult/DeleteHostAgentScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteHostAgentScanResultResponse>
                transformer =
                        DeleteHostAgentScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteHostAgentScanResultRequest, DeleteHostAgentScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteHostAgentScanResultRequest,
                                DeleteHostAgentScanResultResponse>,
                        java.util.concurrent.Future<DeleteHostAgentScanResultResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteHostAgentScanResultRequest, DeleteHostAgentScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteHostCisBenchmarkScanResultResponse>
            deleteHostCisBenchmarkScanResult(
                    DeleteHostCisBenchmarkScanResultRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    DeleteHostCisBenchmarkScanResultRequest,
                                    DeleteHostCisBenchmarkScanResultResponse>
                            handler) {
        LOG.trace("Called async deleteHostCisBenchmarkScanResult");
        final DeleteHostCisBenchmarkScanResultRequest interceptedRequest =
                DeleteHostCisBenchmarkScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteHostCisBenchmarkScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteHostCisBenchmarkScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostCisBenchmarkScanResult/DeleteHostCisBenchmarkScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteHostCisBenchmarkScanResultResponse>
                transformer =
                        DeleteHostCisBenchmarkScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteHostCisBenchmarkScanResultRequest,
                        DeleteHostCisBenchmarkScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteHostCisBenchmarkScanResultRequest,
                                DeleteHostCisBenchmarkScanResultResponse>,
                        java.util.concurrent.Future<DeleteHostCisBenchmarkScanResultResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteHostCisBenchmarkScanResultRequest,
                    DeleteHostCisBenchmarkScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteHostEndpointProtectionScanResultResponse>
            deleteHostEndpointProtectionScanResult(
                    DeleteHostEndpointProtectionScanResultRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    DeleteHostEndpointProtectionScanResultRequest,
                                    DeleteHostEndpointProtectionScanResultResponse>
                            handler) {
        LOG.trace("Called async deleteHostEndpointProtectionScanResult");
        final DeleteHostEndpointProtectionScanResultRequest interceptedRequest =
                DeleteHostEndpointProtectionScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteHostEndpointProtectionScanResultConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteHostEndpointProtectionScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostEndpointProtectionScanResult/DeleteHostEndpointProtectionScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteHostEndpointProtectionScanResultResponse>
                transformer =
                        DeleteHostEndpointProtectionScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteHostEndpointProtectionScanResultRequest,
                        DeleteHostEndpointProtectionScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteHostEndpointProtectionScanResultRequest,
                                DeleteHostEndpointProtectionScanResultResponse>,
                        java.util.concurrent.Future<DeleteHostEndpointProtectionScanResultResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteHostEndpointProtectionScanResultRequest,
                    DeleteHostEndpointProtectionScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteHostPortScanResultResponse> deleteHostPortScanResult(
            DeleteHostPortScanResultRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteHostPortScanResultRequest, DeleteHostPortScanResultResponse>
                    handler) {
        LOG.trace("Called async deleteHostPortScanResult");
        final DeleteHostPortScanResultRequest interceptedRequest =
                DeleteHostPortScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteHostPortScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteHostPortScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostPortScanResult/DeleteHostPortScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, DeleteHostPortScanResultResponse>
                transformer =
                        DeleteHostPortScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteHostPortScanResultRequest, DeleteHostPortScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteHostPortScanResultRequest, DeleteHostPortScanResultResponse>,
                        java.util.concurrent.Future<DeleteHostPortScanResultResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteHostPortScanResultRequest, DeleteHostPortScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteHostScanRecipeResponse> deleteHostScanRecipe(
            DeleteHostScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteHostScanRecipeRequest, DeleteHostScanRecipeResponse>
                    handler) {
        LOG.trace("Called async deleteHostScanRecipe");
        final DeleteHostScanRecipeRequest interceptedRequest =
                DeleteHostScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteHostScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteHostScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanRecipe/DeleteHostScanRecipe");
        final java.util.function.Function<javax.ws.rs.core.Response, DeleteHostScanRecipeResponse>
                transformer =
                        DeleteHostScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteHostScanRecipeRequest, DeleteHostScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteHostScanRecipeRequest, DeleteHostScanRecipeResponse>,
                        java.util.concurrent.Future<DeleteHostScanRecipeResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteHostScanRecipeRequest, DeleteHostScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<DeleteHostScanTargetResponse> deleteHostScanTarget(
            DeleteHostScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            DeleteHostScanTargetRequest, DeleteHostScanTargetResponse>
                    handler) {
        LOG.trace("Called async deleteHostScanTarget");
        final DeleteHostScanTargetRequest interceptedRequest =
                DeleteHostScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                DeleteHostScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "DeleteHostScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTarget/DeleteHostScanTarget");
        final java.util.function.Function<javax.ws.rs.core.Response, DeleteHostScanTargetResponse>
                transformer =
                        DeleteHostScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        DeleteHostScanTargetRequest, DeleteHostScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                DeleteHostScanTargetRequest, DeleteHostScanTargetResponse>,
                        java.util.concurrent.Future<DeleteHostScanTargetResponse>>
                futureSupplier = client.deleteFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    DeleteHostScanTargetRequest, DeleteHostScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ExportHostAgentScanResultCsvResponse>
            exportHostAgentScanResultCsv(
                    ExportHostAgentScanResultCsvRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ExportHostAgentScanResultCsvRequest,
                                    ExportHostAgentScanResultCsvResponse>
                            handler) {
        LOG.trace("Called async exportHostAgentScanResultCsv");
        if (com.oracle.bmc.http.ApacheUtils.isExtraStreamLogsEnabled()) {
            LOG.warn(
                    "exportHostAgentScanResultCsv returns a stream, please make sure to close the stream to avoid any indefinite hangs");
            if (this.apacheConnectionClosingStrategy != null) {
                LOG.warn(
                        "ApacheConnectionClosingStrategy set to {}. For large streams with partial reads of stream, please use ImmediateClosingStrategy. "
                                + "For small streams with partial reads of stream, please use GracefulClosingStrategy. More info in ApacheConnectorProperties",
                        this.apacheConnectionClosingStrategy);
            }
        }
        final ExportHostAgentScanResultCsvRequest interceptedRequest =
                ExportHostAgentScanResultCsvConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ExportHostAgentScanResultCsvConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ExportHostAgentScanResultCsv",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostAgentScanResult/ExportHostAgentScanResultCsv");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ExportHostAgentScanResultCsvResponse>
                transformer =
                        ExportHostAgentScanResultCsvConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ExportHostAgentScanResultCsvRequest, ExportHostAgentScanResultCsvResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ExportHostAgentScanResultCsvRequest,
                                ExportHostAgentScanResultCsvResponse>,
                        java.util.concurrent.Future<ExportHostAgentScanResultCsvResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getExportHostAgentScanResultCsvDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ExportHostAgentScanResultCsvRequest, ExportHostAgentScanResultCsvResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ExportHostVulnerabilityCsvResponse>
            exportHostVulnerabilityCsv(
                    ExportHostVulnerabilityCsvRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ExportHostVulnerabilityCsvRequest,
                                    ExportHostVulnerabilityCsvResponse>
                            handler) {
        LOG.trace("Called async exportHostVulnerabilityCsv");
        if (com.oracle.bmc.http.ApacheUtils.isExtraStreamLogsEnabled()) {
            LOG.warn(
                    "exportHostVulnerabilityCsv returns a stream, please make sure to close the stream to avoid any indefinite hangs");
            if (this.apacheConnectionClosingStrategy != null) {
                LOG.warn(
                        "ApacheConnectionClosingStrategy set to {}. For large streams with partial reads of stream, please use ImmediateClosingStrategy. "
                                + "For small streams with partial reads of stream, please use GracefulClosingStrategy. More info in ApacheConnectorProperties",
                        this.apacheConnectionClosingStrategy);
            }
        }
        final ExportHostVulnerabilityCsvRequest interceptedRequest =
                ExportHostVulnerabilityCsvConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ExportHostVulnerabilityCsvConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ExportHostVulnerabilityCsv",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostVulnerability/ExportHostVulnerabilityCsv");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ExportHostVulnerabilityCsvResponse>
                transformer =
                        ExportHostVulnerabilityCsvConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ExportHostVulnerabilityCsvRequest, ExportHostVulnerabilityCsvResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ExportHostVulnerabilityCsvRequest,
                                ExportHostVulnerabilityCsvResponse>,
                        java.util.concurrent.Future<ExportHostVulnerabilityCsvResponse>>
                futureSupplier =
                        client.postFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getExportHostVulnerabilityCsvDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ExportHostVulnerabilityCsvRequest, ExportHostVulnerabilityCsvResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetContainerScanRecipeResponse> getContainerScanRecipe(
            GetContainerScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetContainerScanRecipeRequest, GetContainerScanRecipeResponse>
                    handler) {
        LOG.trace("Called async getContainerScanRecipe");
        final GetContainerScanRecipeRequest interceptedRequest =
                GetContainerScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetContainerScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetContainerScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanRecipe/GetContainerScanRecipe");
        final java.util.function.Function<javax.ws.rs.core.Response, GetContainerScanRecipeResponse>
                transformer =
                        GetContainerScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetContainerScanRecipeRequest, GetContainerScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetContainerScanRecipeRequest, GetContainerScanRecipeResponse>,
                        java.util.concurrent.Future<GetContainerScanRecipeResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetContainerScanRecipeRequest, GetContainerScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetContainerScanResultResponse> getContainerScanResult(
            GetContainerScanResultRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetContainerScanResultRequest, GetContainerScanResultResponse>
                    handler) {
        LOG.trace("Called async getContainerScanResult");
        final GetContainerScanResultRequest interceptedRequest =
                GetContainerScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetContainerScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetContainerScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanResult/GetContainerScanResult");
        final java.util.function.Function<javax.ws.rs.core.Response, GetContainerScanResultResponse>
                transformer =
                        GetContainerScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetContainerScanResultRequest, GetContainerScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetContainerScanResultRequest, GetContainerScanResultResponse>,
                        java.util.concurrent.Future<GetContainerScanResultResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetContainerScanResultRequest, GetContainerScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetContainerScanTargetResponse> getContainerScanTarget(
            GetContainerScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetContainerScanTargetRequest, GetContainerScanTargetResponse>
                    handler) {
        LOG.trace("Called async getContainerScanTarget");
        final GetContainerScanTargetRequest interceptedRequest =
                GetContainerScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetContainerScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetContainerScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanTarget/GetContainerScanTarget");
        final java.util.function.Function<javax.ws.rs.core.Response, GetContainerScanTargetResponse>
                transformer =
                        GetContainerScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetContainerScanTargetRequest, GetContainerScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetContainerScanTargetRequest, GetContainerScanTargetResponse>,
                        java.util.concurrent.Future<GetContainerScanTargetResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetContainerScanTargetRequest, GetContainerScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostAgentScanResultResponse> getHostAgentScanResult(
            GetHostAgentScanResultRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetHostAgentScanResultRequest, GetHostAgentScanResultResponse>
                    handler) {
        LOG.trace("Called async getHostAgentScanResult");
        final GetHostAgentScanResultRequest interceptedRequest =
                GetHostAgentScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostAgentScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostAgentScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostAgentScanResult/GetHostAgentScanResult");
        final java.util.function.Function<javax.ws.rs.core.Response, GetHostAgentScanResultResponse>
                transformer =
                        GetHostAgentScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetHostAgentScanResultRequest, GetHostAgentScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostAgentScanResultRequest, GetHostAgentScanResultResponse>,
                        java.util.concurrent.Future<GetHostAgentScanResultResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostAgentScanResultRequest, GetHostAgentScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostCisBenchmarkScanResultResponse>
            getHostCisBenchmarkScanResult(
                    GetHostCisBenchmarkScanResultRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    GetHostCisBenchmarkScanResultRequest,
                                    GetHostCisBenchmarkScanResultResponse>
                            handler) {
        LOG.trace("Called async getHostCisBenchmarkScanResult");
        final GetHostCisBenchmarkScanResultRequest interceptedRequest =
                GetHostCisBenchmarkScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostCisBenchmarkScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostCisBenchmarkScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostCisBenchmarkScanResult/GetHostCisBenchmarkScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, GetHostCisBenchmarkScanResultResponse>
                transformer =
                        GetHostCisBenchmarkScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetHostCisBenchmarkScanResultRequest, GetHostCisBenchmarkScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostCisBenchmarkScanResultRequest,
                                GetHostCisBenchmarkScanResultResponse>,
                        java.util.concurrent.Future<GetHostCisBenchmarkScanResultResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostCisBenchmarkScanResultRequest, GetHostCisBenchmarkScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostEndpointProtectionScanResultResponse>
            getHostEndpointProtectionScanResult(
                    GetHostEndpointProtectionScanResultRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    GetHostEndpointProtectionScanResultRequest,
                                    GetHostEndpointProtectionScanResultResponse>
                            handler) {
        LOG.trace("Called async getHostEndpointProtectionScanResult");
        final GetHostEndpointProtectionScanResultRequest interceptedRequest =
                GetHostEndpointProtectionScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostEndpointProtectionScanResultConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostEndpointProtectionScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostEndpointProtectionScanResult/GetHostEndpointProtectionScanResult");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, GetHostEndpointProtectionScanResultResponse>
                transformer =
                        GetHostEndpointProtectionScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetHostEndpointProtectionScanResultRequest,
                        GetHostEndpointProtectionScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostEndpointProtectionScanResultRequest,
                                GetHostEndpointProtectionScanResultResponse>,
                        java.util.concurrent.Future<GetHostEndpointProtectionScanResultResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostEndpointProtectionScanResultRequest,
                    GetHostEndpointProtectionScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostPortScanResultResponse> getHostPortScanResult(
            GetHostPortScanResultRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetHostPortScanResultRequest, GetHostPortScanResultResponse>
                    handler) {
        LOG.trace("Called async getHostPortScanResult");
        final GetHostPortScanResultRequest interceptedRequest =
                GetHostPortScanResultConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostPortScanResultConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostPortScanResult",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostPortScanResult/GetHostPortScanResult");
        final java.util.function.Function<javax.ws.rs.core.Response, GetHostPortScanResultResponse>
                transformer =
                        GetHostPortScanResultConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetHostPortScanResultRequest, GetHostPortScanResultResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostPortScanResultRequest, GetHostPortScanResultResponse>,
                        java.util.concurrent.Future<GetHostPortScanResultResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostPortScanResultRequest, GetHostPortScanResultResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostScanRecipeResponse> getHostScanRecipe(
            GetHostScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetHostScanRecipeRequest, GetHostScanRecipeResponse>
                    handler) {
        LOG.trace("Called async getHostScanRecipe");
        final GetHostScanRecipeRequest interceptedRequest =
                GetHostScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanRecipe/GetHostScanRecipe");
        final java.util.function.Function<javax.ws.rs.core.Response, GetHostScanRecipeResponse>
                transformer =
                        GetHostScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<GetHostScanRecipeRequest, GetHostScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostScanRecipeRequest, GetHostScanRecipeResponse>,
                        java.util.concurrent.Future<GetHostScanRecipeResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostScanRecipeRequest, GetHostScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostScanTargetResponse> getHostScanTarget(
            GetHostScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetHostScanTargetRequest, GetHostScanTargetResponse>
                    handler) {
        LOG.trace("Called async getHostScanTarget");
        final GetHostScanTargetRequest interceptedRequest =
                GetHostScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTarget/GetHostScanTarget");
        final java.util.function.Function<javax.ws.rs.core.Response, GetHostScanTargetResponse>
                transformer =
                        GetHostScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<GetHostScanTargetRequest, GetHostScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostScanTargetRequest, GetHostScanTargetResponse>,
                        java.util.concurrent.Future<GetHostScanTargetResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostScanTargetRequest, GetHostScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetHostVulnerabilityResponse> getHostVulnerability(
            GetHostVulnerabilityRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetHostVulnerabilityRequest, GetHostVulnerabilityResponse>
                    handler) {
        LOG.trace("Called async getHostVulnerability");
        final GetHostVulnerabilityRequest interceptedRequest =
                GetHostVulnerabilityConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetHostVulnerabilityConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetHostVulnerability",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostVulnerability/GetHostVulnerability");
        final java.util.function.Function<javax.ws.rs.core.Response, GetHostVulnerabilityResponse>
                transformer =
                        GetHostVulnerabilityConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        GetHostVulnerabilityRequest, GetHostVulnerabilityResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetHostVulnerabilityRequest, GetHostVulnerabilityResponse>,
                        java.util.concurrent.Future<GetHostVulnerabilityResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetHostVulnerabilityRequest, GetHostVulnerabilityResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetVulnerabilityResponse> getVulnerability(
            GetVulnerabilityRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetVulnerabilityRequest, GetVulnerabilityResponse>
                    handler) {
        LOG.trace("Called async getVulnerability");
        final GetVulnerabilityRequest interceptedRequest =
                GetVulnerabilityConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetVulnerabilityConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetVulnerability",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/Vulnerability/GetVulnerability");
        final java.util.function.Function<javax.ws.rs.core.Response, GetVulnerabilityResponse>
                transformer =
                        GetVulnerabilityConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<GetVulnerabilityRequest, GetVulnerabilityResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetVulnerabilityRequest, GetVulnerabilityResponse>,
                        java.util.concurrent.Future<GetVulnerabilityResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetVulnerabilityRequest, GetVulnerabilityResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<GetWorkRequestResponse> getWorkRequest(
            GetWorkRequestRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            GetWorkRequestRequest, GetWorkRequestResponse>
                    handler) {
        LOG.trace("Called async getWorkRequest");
        final GetWorkRequestRequest interceptedRequest =
                GetWorkRequestConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GetWorkRequestConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "GetWorkRequest",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/WorkRequest/GetWorkRequest");
        final java.util.function.Function<javax.ws.rs.core.Response, GetWorkRequestResponse>
                transformer =
                        GetWorkRequestConverter.fromResponse(java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<GetWorkRequestRequest, GetWorkRequestResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                GetWorkRequestRequest, GetWorkRequestResponse>,
                        java.util.concurrent.Future<GetWorkRequestResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    GetWorkRequestRequest, GetWorkRequestResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListContainerScanRecipesResponse> listContainerScanRecipes(
            ListContainerScanRecipesRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListContainerScanRecipesRequest, ListContainerScanRecipesResponse>
                    handler) {
        LOG.trace("Called async listContainerScanRecipes");
        final ListContainerScanRecipesRequest interceptedRequest =
                ListContainerScanRecipesConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListContainerScanRecipesConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListContainerScanRecipes",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanRecipe/ListContainerScanRecipes");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListContainerScanRecipesResponse>
                transformer =
                        ListContainerScanRecipesConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListContainerScanRecipesRequest, ListContainerScanRecipesResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListContainerScanRecipesRequest, ListContainerScanRecipesResponse>,
                        java.util.concurrent.Future<ListContainerScanRecipesResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListContainerScanRecipesRequest, ListContainerScanRecipesResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListContainerScanResultsResponse> listContainerScanResults(
            ListContainerScanResultsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListContainerScanResultsRequest, ListContainerScanResultsResponse>
                    handler) {
        LOG.trace("Called async listContainerScanResults");
        final ListContainerScanResultsRequest interceptedRequest =
                ListContainerScanResultsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListContainerScanResultsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListContainerScanResults",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanResult/ListContainerScanResults");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListContainerScanResultsResponse>
                transformer =
                        ListContainerScanResultsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListContainerScanResultsRequest, ListContainerScanResultsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListContainerScanResultsRequest, ListContainerScanResultsResponse>,
                        java.util.concurrent.Future<ListContainerScanResultsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListContainerScanResultsRequest, ListContainerScanResultsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListContainerScanTargetsResponse> listContainerScanTargets(
            ListContainerScanTargetsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListContainerScanTargetsRequest, ListContainerScanTargetsResponse>
                    handler) {
        LOG.trace("Called async listContainerScanTargets");
        final ListContainerScanTargetsRequest interceptedRequest =
                ListContainerScanTargetsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListContainerScanTargetsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListContainerScanTargets",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanTarget/ListContainerScanTargets");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListContainerScanTargetsResponse>
                transformer =
                        ListContainerScanTargetsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListContainerScanTargetsRequest, ListContainerScanTargetsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListContainerScanTargetsRequest, ListContainerScanTargetsResponse>,
                        java.util.concurrent.Future<ListContainerScanTargetsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListContainerScanTargetsRequest, ListContainerScanTargetsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostAgentScanResultsResponse> listHostAgentScanResults(
            ListHostAgentScanResultsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListHostAgentScanResultsRequest, ListHostAgentScanResultsResponse>
                    handler) {
        LOG.trace("Called async listHostAgentScanResults");
        final ListHostAgentScanResultsRequest interceptedRequest =
                ListHostAgentScanResultsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostAgentScanResultsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostAgentScanResults",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostAgentScanResult/ListHostAgentScanResults");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostAgentScanResultsResponse>
                transformer =
                        ListHostAgentScanResultsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostAgentScanResultsRequest, ListHostAgentScanResultsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostAgentScanResultsRequest, ListHostAgentScanResultsResponse>,
                        java.util.concurrent.Future<ListHostAgentScanResultsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostAgentScanResultsRequest, ListHostAgentScanResultsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostCisBenchmarkScanResultsResponse>
            listHostCisBenchmarkScanResults(
                    ListHostCisBenchmarkScanResultsRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ListHostCisBenchmarkScanResultsRequest,
                                    ListHostCisBenchmarkScanResultsResponse>
                            handler) {
        LOG.trace("Called async listHostCisBenchmarkScanResults");
        final ListHostCisBenchmarkScanResultsRequest interceptedRequest =
                ListHostCisBenchmarkScanResultsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostCisBenchmarkScanResultsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostCisBenchmarkScanResults",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostCisBenchmarkScanResult/ListHostCisBenchmarkScanResults");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostCisBenchmarkScanResultsResponse>
                transformer =
                        ListHostCisBenchmarkScanResultsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostCisBenchmarkScanResultsRequest,
                        ListHostCisBenchmarkScanResultsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostCisBenchmarkScanResultsRequest,
                                ListHostCisBenchmarkScanResultsResponse>,
                        java.util.concurrent.Future<ListHostCisBenchmarkScanResultsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostCisBenchmarkScanResultsRequest,
                    ListHostCisBenchmarkScanResultsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostEndpointProtectionScanResultsResponse>
            listHostEndpointProtectionScanResults(
                    ListHostEndpointProtectionScanResultsRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ListHostEndpointProtectionScanResultsRequest,
                                    ListHostEndpointProtectionScanResultsResponse>
                            handler) {
        LOG.trace("Called async listHostEndpointProtectionScanResults");
        final ListHostEndpointProtectionScanResultsRequest interceptedRequest =
                ListHostEndpointProtectionScanResultsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostEndpointProtectionScanResultsConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostEndpointProtectionScanResults",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostEndpointProtectionScanResult/ListHostEndpointProtectionScanResults");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostEndpointProtectionScanResultsResponse>
                transformer =
                        ListHostEndpointProtectionScanResultsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostEndpointProtectionScanResultsRequest,
                        ListHostEndpointProtectionScanResultsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostEndpointProtectionScanResultsRequest,
                                ListHostEndpointProtectionScanResultsResponse>,
                        java.util.concurrent.Future<ListHostEndpointProtectionScanResultsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostEndpointProtectionScanResultsRequest,
                    ListHostEndpointProtectionScanResultsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostPortScanResultsResponse> listHostPortScanResults(
            ListHostPortScanResultsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListHostPortScanResultsRequest, ListHostPortScanResultsResponse>
                    handler) {
        LOG.trace("Called async listHostPortScanResults");
        final ListHostPortScanResultsRequest interceptedRequest =
                ListHostPortScanResultsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostPortScanResultsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostPortScanResults",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostPortScanResult/ListHostPortScanResults");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostPortScanResultsResponse>
                transformer =
                        ListHostPortScanResultsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostPortScanResultsRequest, ListHostPortScanResultsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostPortScanResultsRequest, ListHostPortScanResultsResponse>,
                        java.util.concurrent.Future<ListHostPortScanResultsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostPortScanResultsRequest, ListHostPortScanResultsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostScanRecipesResponse> listHostScanRecipes(
            ListHostScanRecipesRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListHostScanRecipesRequest, ListHostScanRecipesResponse>
                    handler) {
        LOG.trace("Called async listHostScanRecipes");
        final ListHostScanRecipesRequest interceptedRequest =
                ListHostScanRecipesConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostScanRecipesConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostScanRecipes",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanRecipe/ListHostScanRecipes");
        final java.util.function.Function<javax.ws.rs.core.Response, ListHostScanRecipesResponse>
                transformer =
                        ListHostScanRecipesConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostScanRecipesRequest, ListHostScanRecipesResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostScanRecipesRequest, ListHostScanRecipesResponse>,
                        java.util.concurrent.Future<ListHostScanRecipesResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostScanRecipesRequest, ListHostScanRecipesResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostScanTargetErrorsResponse> listHostScanTargetErrors(
            ListHostScanTargetErrorsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListHostScanTargetErrorsRequest, ListHostScanTargetErrorsResponse>
                    handler) {
        LOG.trace("Called async listHostScanTargetErrors");
        final ListHostScanTargetErrorsRequest interceptedRequest =
                ListHostScanTargetErrorsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostScanTargetErrorsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostScanTargetErrors",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTargetErrorSummaryCollection/ListHostScanTargetErrors");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostScanTargetErrorsResponse>
                transformer =
                        ListHostScanTargetErrorsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostScanTargetErrorsRequest, ListHostScanTargetErrorsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostScanTargetErrorsRequest, ListHostScanTargetErrorsResponse>,
                        java.util.concurrent.Future<ListHostScanTargetErrorsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostScanTargetErrorsRequest, ListHostScanTargetErrorsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostScanTargetsResponse> listHostScanTargets(
            ListHostScanTargetsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListHostScanTargetsRequest, ListHostScanTargetsResponse>
                    handler) {
        LOG.trace("Called async listHostScanTargets");
        final ListHostScanTargetsRequest interceptedRequest =
                ListHostScanTargetsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostScanTargetsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostScanTargets",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTarget/ListHostScanTargets");
        final java.util.function.Function<javax.ws.rs.core.Response, ListHostScanTargetsResponse>
                transformer =
                        ListHostScanTargetsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostScanTargetsRequest, ListHostScanTargetsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostScanTargetsRequest, ListHostScanTargetsResponse>,
                        java.util.concurrent.Future<ListHostScanTargetsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostScanTargetsRequest, ListHostScanTargetsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostVulnerabilitiesResponse> listHostVulnerabilities(
            ListHostVulnerabilitiesRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListHostVulnerabilitiesRequest, ListHostVulnerabilitiesResponse>
                    handler) {
        LOG.trace("Called async listHostVulnerabilities");
        final ListHostVulnerabilitiesRequest interceptedRequest =
                ListHostVulnerabilitiesConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostVulnerabilitiesConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostVulnerabilities",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostVulnerability/ListHostVulnerabilities");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostVulnerabilitiesResponse>
                transformer =
                        ListHostVulnerabilitiesConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostVulnerabilitiesRequest, ListHostVulnerabilitiesResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostVulnerabilitiesRequest, ListHostVulnerabilitiesResponse>,
                        java.util.concurrent.Future<ListHostVulnerabilitiesResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostVulnerabilitiesRequest, ListHostVulnerabilitiesResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListHostVulnerabilityImpactedHostsResponse>
            listHostVulnerabilityImpactedHosts(
                    ListHostVulnerabilityImpactedHostsRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ListHostVulnerabilityImpactedHostsRequest,
                                    ListHostVulnerabilityImpactedHostsResponse>
                            handler) {
        LOG.trace("Called async listHostVulnerabilityImpactedHosts");
        final ListHostVulnerabilityImpactedHostsRequest interceptedRequest =
                ListHostVulnerabilityImpactedHostsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListHostVulnerabilityImpactedHostsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListHostVulnerabilityImpactedHosts",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostVulnerability/ListHostVulnerabilityImpactedHosts");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListHostVulnerabilityImpactedHostsResponse>
                transformer =
                        ListHostVulnerabilityImpactedHostsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListHostVulnerabilityImpactedHostsRequest,
                        ListHostVulnerabilityImpactedHostsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListHostVulnerabilityImpactedHostsRequest,
                                ListHostVulnerabilityImpactedHostsResponse>,
                        java.util.concurrent.Future<ListHostVulnerabilityImpactedHostsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListHostVulnerabilityImpactedHostsRequest,
                    ListHostVulnerabilityImpactedHostsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListVulnerabilitiesResponse> listVulnerabilities(
            ListVulnerabilitiesRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListVulnerabilitiesRequest, ListVulnerabilitiesResponse>
                    handler) {
        LOG.trace("Called async listVulnerabilities");
        final ListVulnerabilitiesRequest interceptedRequest =
                ListVulnerabilitiesConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListVulnerabilitiesConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListVulnerabilities",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/Vulnerability/ListVulnerabilities");
        final java.util.function.Function<javax.ws.rs.core.Response, ListVulnerabilitiesResponse>
                transformer =
                        ListVulnerabilitiesConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListVulnerabilitiesRequest, ListVulnerabilitiesResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListVulnerabilitiesRequest, ListVulnerabilitiesResponse>,
                        java.util.concurrent.Future<ListVulnerabilitiesResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListVulnerabilitiesRequest, ListVulnerabilitiesResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListVulnerabilityImpactedContainersResponse>
            listVulnerabilityImpactedContainers(
                    ListVulnerabilityImpactedContainersRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ListVulnerabilityImpactedContainersRequest,
                                    ListVulnerabilityImpactedContainersResponse>
                            handler) {
        LOG.trace("Called async listVulnerabilityImpactedContainers");
        final ListVulnerabilityImpactedContainersRequest interceptedRequest =
                ListVulnerabilityImpactedContainersConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListVulnerabilityImpactedContainersConverter.fromRequest(
                        client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListVulnerabilityImpactedContainers",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/Vulnerability/ListVulnerabilityImpactedContainers");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListVulnerabilityImpactedContainersResponse>
                transformer =
                        ListVulnerabilityImpactedContainersConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListVulnerabilityImpactedContainersRequest,
                        ListVulnerabilityImpactedContainersResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListVulnerabilityImpactedContainersRequest,
                                ListVulnerabilityImpactedContainersResponse>,
                        java.util.concurrent.Future<ListVulnerabilityImpactedContainersResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListVulnerabilityImpactedContainersRequest,
                    ListVulnerabilityImpactedContainersResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListVulnerabilityImpactedHostsResponse>
            listVulnerabilityImpactedHosts(
                    ListVulnerabilityImpactedHostsRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    ListVulnerabilityImpactedHostsRequest,
                                    ListVulnerabilityImpactedHostsResponse>
                            handler) {
        LOG.trace("Called async listVulnerabilityImpactedHosts");
        final ListVulnerabilityImpactedHostsRequest interceptedRequest =
                ListVulnerabilityImpactedHostsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListVulnerabilityImpactedHostsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListVulnerabilityImpactedHosts",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/Vulnerability/ListVulnerabilityImpactedHosts");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, ListVulnerabilityImpactedHostsResponse>
                transformer =
                        ListVulnerabilityImpactedHostsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListVulnerabilityImpactedHostsRequest,
                        ListVulnerabilityImpactedHostsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListVulnerabilityImpactedHostsRequest,
                                ListVulnerabilityImpactedHostsResponse>,
                        java.util.concurrent.Future<ListVulnerabilityImpactedHostsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListVulnerabilityImpactedHostsRequest, ListVulnerabilityImpactedHostsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListWorkRequestErrorsResponse> listWorkRequestErrors(
            ListWorkRequestErrorsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListWorkRequestErrorsRequest, ListWorkRequestErrorsResponse>
                    handler) {
        LOG.trace("Called async listWorkRequestErrors");
        final ListWorkRequestErrorsRequest interceptedRequest =
                ListWorkRequestErrorsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListWorkRequestErrorsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListWorkRequestErrors",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/WorkRequestError/ListWorkRequestErrors");
        final java.util.function.Function<javax.ws.rs.core.Response, ListWorkRequestErrorsResponse>
                transformer =
                        ListWorkRequestErrorsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListWorkRequestErrorsRequest, ListWorkRequestErrorsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListWorkRequestErrorsRequest, ListWorkRequestErrorsResponse>,
                        java.util.concurrent.Future<ListWorkRequestErrorsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListWorkRequestErrorsRequest, ListWorkRequestErrorsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListWorkRequestLogsResponse> listWorkRequestLogs(
            ListWorkRequestLogsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListWorkRequestLogsRequest, ListWorkRequestLogsResponse>
                    handler) {
        LOG.trace("Called async listWorkRequestLogs");
        final ListWorkRequestLogsRequest interceptedRequest =
                ListWorkRequestLogsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListWorkRequestLogsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListWorkRequestLogs",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/WorkRequestLogEntry/ListWorkRequestLogs");
        final java.util.function.Function<javax.ws.rs.core.Response, ListWorkRequestLogsResponse>
                transformer =
                        ListWorkRequestLogsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        ListWorkRequestLogsRequest, ListWorkRequestLogsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListWorkRequestLogsRequest, ListWorkRequestLogsResponse>,
                        java.util.concurrent.Future<ListWorkRequestLogsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListWorkRequestLogsRequest, ListWorkRequestLogsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<ListWorkRequestsResponse> listWorkRequests(
            ListWorkRequestsRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            ListWorkRequestsRequest, ListWorkRequestsResponse>
                    handler) {
        LOG.trace("Called async listWorkRequests");
        final ListWorkRequestsRequest interceptedRequest =
                ListWorkRequestsConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                ListWorkRequestsConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "ListWorkRequests",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/WorkRequest/ListWorkRequests");
        final java.util.function.Function<javax.ws.rs.core.Response, ListWorkRequestsResponse>
                transformer =
                        ListWorkRequestsConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<ListWorkRequestsRequest, ListWorkRequestsResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                ListWorkRequestsRequest, ListWorkRequestsResponse>,
                        java.util.concurrent.Future<ListWorkRequestsResponse>>
                futureSupplier = client.getFutureSupplier(interceptedRequest, ib, transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    ListWorkRequestsRequest, ListWorkRequestsResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<UpdateContainerScanRecipeResponse> updateContainerScanRecipe(
            UpdateContainerScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            UpdateContainerScanRecipeRequest, UpdateContainerScanRecipeResponse>
                    handler) {
        LOG.trace("Called async updateContainerScanRecipe");
        final UpdateContainerScanRecipeRequest interceptedRequest =
                UpdateContainerScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                UpdateContainerScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "UpdateContainerScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanRecipe/UpdateContainerScanRecipe");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, UpdateContainerScanRecipeResponse>
                transformer =
                        UpdateContainerScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        UpdateContainerScanRecipeRequest, UpdateContainerScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                UpdateContainerScanRecipeRequest,
                                UpdateContainerScanRecipeResponse>,
                        java.util.concurrent.Future<UpdateContainerScanRecipeResponse>>
                futureSupplier =
                        client.putFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getUpdateContainerScanRecipeDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    UpdateContainerScanRecipeRequest, UpdateContainerScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<UpdateContainerScanTargetResponse> updateContainerScanTarget(
            UpdateContainerScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            UpdateContainerScanTargetRequest, UpdateContainerScanTargetResponse>
                    handler) {
        LOG.trace("Called async updateContainerScanTarget");
        final UpdateContainerScanTargetRequest interceptedRequest =
                UpdateContainerScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                UpdateContainerScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "UpdateContainerScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/ContainerScanTarget/UpdateContainerScanTarget");
        final java.util.function.Function<
                        javax.ws.rs.core.Response, UpdateContainerScanTargetResponse>
                transformer =
                        UpdateContainerScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        UpdateContainerScanTargetRequest, UpdateContainerScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                UpdateContainerScanTargetRequest,
                                UpdateContainerScanTargetResponse>,
                        java.util.concurrent.Future<UpdateContainerScanTargetResponse>>
                futureSupplier =
                        client.putFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getUpdateContainerScanTargetDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    UpdateContainerScanTargetRequest, UpdateContainerScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<UpdateHostScanRecipeResponse> updateHostScanRecipe(
            UpdateHostScanRecipeRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            UpdateHostScanRecipeRequest, UpdateHostScanRecipeResponse>
                    handler) {
        LOG.trace("Called async updateHostScanRecipe");
        final UpdateHostScanRecipeRequest interceptedRequest =
                UpdateHostScanRecipeConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                UpdateHostScanRecipeConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "UpdateHostScanRecipe",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanRecipe/UpdateHostScanRecipe");
        final java.util.function.Function<javax.ws.rs.core.Response, UpdateHostScanRecipeResponse>
                transformer =
                        UpdateHostScanRecipeConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        UpdateHostScanRecipeRequest, UpdateHostScanRecipeResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                UpdateHostScanRecipeRequest, UpdateHostScanRecipeResponse>,
                        java.util.concurrent.Future<UpdateHostScanRecipeResponse>>
                futureSupplier =
                        client.putFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getUpdateHostScanRecipeDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    UpdateHostScanRecipeRequest, UpdateHostScanRecipeResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }

    @Override
    public java.util.concurrent.Future<UpdateHostScanTargetResponse> updateHostScanTarget(
            UpdateHostScanTargetRequest request,
            final com.oracle.bmc.responses.AsyncHandler<
                            UpdateHostScanTargetRequest, UpdateHostScanTargetResponse>
                    handler) {
        LOG.trace("Called async updateHostScanTarget");
        final UpdateHostScanTargetRequest interceptedRequest =
                UpdateHostScanTargetConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                UpdateHostScanTargetConverter.fromRequest(client, interceptedRequest);
        com.oracle.bmc.ServiceDetails serviceDetails =
                new com.oracle.bmc.ServiceDetails(
                        "VulnerabilityScanning",
                        "UpdateHostScanTarget",
                        ib.getRequestUri().toString(),
                        "https://docs.oracle.com/iaas/api/#/en/scanning/20210215/HostScanTarget/UpdateHostScanTarget");
        final java.util.function.Function<javax.ws.rs.core.Response, UpdateHostScanTargetResponse>
                transformer =
                        UpdateHostScanTargetConverter.fromResponse(
                                java.util.Optional.of(serviceDetails));
        com.oracle.bmc.responses.AsyncHandler<
                        UpdateHostScanTargetRequest, UpdateHostScanTargetResponse>
                handlerToUse = handler;

        java.util.function.Function<
                        com.oracle.bmc.responses.AsyncHandler<
                                UpdateHostScanTargetRequest, UpdateHostScanTargetResponse>,
                        java.util.concurrent.Future<UpdateHostScanTargetResponse>>
                futureSupplier =
                        client.putFutureSupplier(
                                interceptedRequest,
                                interceptedRequest.getUpdateHostScanTargetDetails(),
                                ib,
                                transformer);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenWrapper<
                    UpdateHostScanTargetRequest, UpdateHostScanTargetResponse>(
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    handlerToUse,
                    futureSupplier) {
                @Override
                protected void beforeRetryAction() {}
            };
        } else {
            return futureSupplier.apply(handlerToUse);
        }
    }
}
